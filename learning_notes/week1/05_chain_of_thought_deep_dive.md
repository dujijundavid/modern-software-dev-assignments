# Chain of Thought Prompting：深度学习指南

## 📋 目录
1. [核心概念：什么是Chain of Thought？](#核心概念什么是chain-of-thought)
2. [问题诊断：当前脚本的问题](#问题诊断当前脚本的问题)
3. [实验设计：科学的对比学习框架](#实验设计科学的对比学习框架)
4. [思考问题：引导深入理解](#思考问题引导深入理解)
5. [与AI Coding Agent协作的方法论](#与ai-coding-agent协作的方法论)
6. [CoT的变体与进阶](#cot的变体与进阶)

---

## 核心概念：什么是Chain of Thought？

### 🧠 核心思想

> **Chain of Thought (CoT)** 的本质是：让模型在输出最终答案之前，**显式地展示中间推理步骤**。

```
┌─────────────────────────────────────────────────────────────┐
│  传统 Prompting (Direct Answer)                              │
│  ────────────────────────────────                            │
│  问题: 3^12345 mod 100 = ?                                   │
│  模型: 43                                                    │
│                                                              │
│  问题: 模型是怎么得到43的？                                   │
│  答案: 不知道！模型直接"猜"了一个答案                         │
├─────────────────────────────────────────────────────────────┤
│  Chain of Thought Prompting                                  │
│  ────────────────────────────────                            │
│  问题: 3^12345 mod 100 = ? 请一步步思考                       │
│  模型:                                                       │
│    1. 首先，我需要找到3的幂次对100取模的规律                  │
│    2. 3^1=3, 3^2=9, 3^3=27, 3^4=81, 3^5=243≡43(mod100)...   │
│    3. 发现周期是40 (欧拉定理: φ(100)=40)                     │
│    4. 12345 = 40×308 + 25, 所以 3^12345 ≡ 3^25 (mod 100)    │
│    5. 计算 3^25 mod 100 = 43                                 │
│    Answer: 43                                                │
│                                                              │
│  问题: 模型是怎么得到43的？                                   │
│  答案: 完整的推理链！可验证、可调试                           │
└─────────────────────────────────────────────────────────────┘
```

### 为什么CoT有效？

| 理论解释 | 说明 |
|---------|------|
| **工作记忆扩展** | 中间步骤相当于给模型提供了"工作记忆"，让它可以追踪复杂状态 |
| **任务分解** | 大问题被分解成小步骤，每一步都是简单任务 |
| **自我验证** | 模型可以在推理过程中检查自己的逻辑 |
| **减少跳跃** | 避免模型直接从问题"跳跃"到答案，减少错误 |

### CoT的三种实现方式

```
┌────────────────────────────────────────────────────────────────────┐
│                     Chain of Thought 变体                           │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. Zero-shot CoT                                                   │
│     ─────────────                                                   │
│     只需添加: "Let's think step by step"                            │
│     优点: 简单、通用                                                 │
│     缺点: 可能不够精确                                               │
│                                                                     │
│  2. Few-shot CoT (示例驱动)                                         │
│     ─────────────                                                   │
│     提供几个带推理过程的示例                                         │
│     优点: 更可控、更准确                                             │
│     缺点: 需要设计高质量示例                                         │
│                                                                     │
│  3. Self-Consistency + CoT                                          │
│     ─────────────────────                                           │
│     多次采样 + 多数投票                                              │
│     优点: 更鲁棒                                                     │
│     缺点: 计算成本高                                                 │
│                                                                     │
└────────────────────────────────────────────────────────────────────┘
```

---

## 问题诊断：当前脚本的问题

### 🔍 代码审查

当前 `chain_of_thought.py` 的 `YOUR_SYSTEM_PROMPT`:

```python
YOUR_SYSTEM_PROMPT = """You are an expert mathematician skilled in modular arithmetic.

When solving exponential modular arithmetic problems:
1. Find the pattern/cycle in powers: Calculate the first several powers mod 100 to identify repeating patterns
2. Use Euler's theorem if applicable (φ(100) = 40, so 3^40 ≡ 1 (mod 100))
3. Reduce the exponent using the cycle length
4. Calculate the final result

For this problem (3^12345 mod 100):                          # ⚠️ 问题特定
- First compute: 3^1, 3^2, 3^4, 3^5, 3^10, 3^20, 3^40 (mod 100) to find patterns
- Since φ(100) = 40, we know 3^40 ≡ 1 (mod 100)              # ⚠️ 答案泄露
- So 3^12345 = 3^(40*308 + 25) = (3^40)^308 * 3^25 ≡ 1^308 * 3^25 ≡ 3^25 (mod 100)
- Calculate 3^25 mod 100 to get the answer                    # ⚠️ 完整解题过程

Show your work step by step, then provide the final answer."""
```

### ❌ 问题清单

| 问题 | 严重性 | 说明 |
|------|--------|------|
| **答案泄露** | 🔴 严重 | Prompt 直接包含了完整的解题步骤，模型只需要"复读" |
| **问题特定** | 🟡 中等 | 专门为 `3^12345 mod 100` 设计，无法测试泛化能力 |
| **无法学习** | 🔴 严重 | 无法区分"CoT有效"和"答案泄露有效" |
| **缺少对比** | 🟡 中等 | 只有一个条件，无法科学评估不同策略的效果 |

### 核心问题

> **这不是 Chain of Thought，这是 Answer Leaking！**

```
┌─────────────────────────────────────────────────────────────┐
│  真正的 CoT: 引导思考方式，不给具体答案                       │
│  ────────────────────────────────────────                    │
│  "请使用欧拉定理来简化指数..."                                │
│  "首先找到幂次的周期..."                                      │
│  模型需要自己推导！                                           │
├─────────────────────────────────────────────────────────────┤
│  答案泄露: 直接告诉模型怎么做                                 │
│  ────────────────────────────────────────                    │
│  "φ(100) = 40, 所以 3^40 ≡ 1 (mod 100)"                      │
│  "3^12345 = 3^(40*308 + 25) = ..."                           │
│  模型只需要复读！                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 实验设计：科学的对比学习框架

### 🔬 实验目标

通过对比不同的 prompting 策略，真正理解 CoT 的效果和适用场景。

### 实验设计矩阵

```
┌──────────────────────────────────────────────────────────────────────────────┐
│                           CoT 对比实验设计                                    │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  实验条件 (5种策略)                                                           │
│  ────────────────────                                                         │
│                                                                               │
│  A. Baseline (Zero-shot, No CoT)                                             │
│     └─ 只问问题，不给任何引导                                                 │
│     └─ 目的：建立基线，看模型"裸奔"的表现                                     │
│                                                                               │
│  B. Generic CoT ("Let's think step by step")                                 │
│     └─ 只添加魔法咒语，不给具体引导                                           │
│     └─ 目的：测试最简单的 CoT 是否有效                                        │
│                                                                               │
│  C. Structured CoT (推理框架)                                                 │
│     └─ 给出思考框架，但不给具体计算                                           │
│     └─ 目的：测试结构化引导的效果                                             │
│                                                                               │
│  D. Domain-Specific CoT (领域知识 + 框架)                                     │
│     └─ 提供相关数学定理，但不直接应用                                         │
│     └─ 目的：测试领域知识注入的效果                                           │
│                                                                               │
│  E. Few-shot CoT (带示例的推理)                                               │
│     └─ 用不同的问题展示完整推理过程                                           │
│     └─ 目的：测试示例驱动的效果                                               │
│                                                                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  测试问题 (至少2个，验证泛化)                                                 │
│  ────────────────────────────                                                 │
│                                                                               │
│  Q1: 3^12345 mod 100 = ?        (原问题)                                      │
│  Q2: 7^2023 mod 13 = ?          (不同的数，测试泛化)                          │
│                                                                               │
├──────────────────────────────────────────────────────────────────────────────┤
│                                                                               │
│  评估维度                                                                     │
│  ────────                                                                     │
│                                                                               │
│  1. 准确率 (Accuracy)                                                         │
│     └─ 最终答案是否正确                                                       │
│                                                                               │
│  2. 推理质量 (Reasoning Quality)                                              │
│     └─ 推理过程是否合理、完整                                                 │
│                                                                               │
│  3. 一致性 (Consistency)                                                      │
│     └─ 多次运行结果是否稳定                                                   │
│                                                                               │
└──────────────────────────────────────────────────────────────────────────────┘
```

### 具体实验设计

#### 策略A: Baseline (无CoT)
```python
STRATEGY_A = """You are a mathematician. Answer math questions accurately."""
```

#### 策略B: Generic CoT
```python
STRATEGY_B = """You are a mathematician. 
When solving problems, think through each step carefully.
Let's think step by step."""
```

#### 策略C: Structured CoT
```python
STRATEGY_C = """You are a mathematician skilled in modular arithmetic.

When solving modular exponentiation problems (a^n mod m):
1. ANALYZE: Identify the base (a), exponent (n), and modulus (m)
2. SIMPLIFY: Look for patterns or theorems to reduce the problem
3. CALCULATE: Perform the calculation step by step
4. VERIFY: Check your answer makes sense

Show each step of your reasoning."""
```

#### 策略D: Domain-Specific CoT
```python
STRATEGY_D = """You are a mathematician skilled in modular arithmetic.

Useful theorems for modular exponentiation:
- Euler's Theorem: a^φ(n) ≡ 1 (mod n) when gcd(a,n)=1
- For n=100: φ(100) = 100 × (1-1/2) × (1-1/5) = 40
- For prime p: φ(p) = p-1

Approach:
1. Check if Euler's theorem applies
2. Find the cycle length
3. Reduce the exponent
4. Calculate the result

Show your work step by step."""
```

#### 策略E: Few-shot CoT
```python
STRATEGY_E = """You are a mathematician. Here are examples of solving modular exponentiation:

Example 1: What is 2^10 mod 7?
Thinking: 
- 2^1=2, 2^2=4, 2^3=8≡1(mod 7)
- So the cycle length is 3
- 10 = 3×3 + 1, so 2^10 ≡ 2^1 = 2 (mod 7)
Answer: 2

Example 2: What is 5^100 mod 13?
Thinking:
- By Fermat's Little Theorem, 5^12 ≡ 1 (mod 13) since 13 is prime
- 100 = 12×8 + 4
- So 5^100 ≡ 5^4 = 625 ≡ 625 - 48×13 = 1 (mod 13)
Answer: 1

Now solve the given problem using similar reasoning."""
```

---

## 思考问题：引导深入理解

### 🤔 第一层：概念理解

1. **为什么"Let's think step by step"这么简单的一句话能提升模型性能？**
   - 提示：考虑模型的工作原理——它是如何生成下一个token的？

2. **CoT和Few-shot Prompting有什么区别？可以结合使用吗？**

3. **什么类型的问题最适合使用CoT？什么类型的问题用CoT反而可能更差？**

### 🤔 第二层：设计思考

4. **在Structured CoT中，如何决定应该给模型什么级别的引导？**
   - 太少：模型可能走偏
   - 太多：变成答案泄露
   - 如何找到平衡点？

5. **为什么Few-shot CoT中示例的选择很重要？**
   - 示例应该和目标问题多相似？
   - 示例的难度应该如何？

6. **如何评估推理质量，而不仅仅是答案正确性？**

### 🤔 第三层：实验设计

7. **如何控制实验中的混淆变量？**
   - 例如：模型的随机性、prompt长度、措辞变化

8. **如果你的实验发现CoT对某个问题无效，可能的原因是什么？**

9. **如何从实验结果中提取可迁移的知识？**

### 🤔 第四层：批判性思考

10. **CoT的局限性是什么？**
    - 模型可能"伪装"推理（输出看起来正确但逻辑实际有问题）
    - 如何检测和避免这种情况？

11. **在实际工程应用中，CoT的成本（更长的输出）是否值得？如何权衡？**

---

## 与AI Coding Agent协作的方法论

### 📖 核心原则：从"代劳者"到"思考伙伴"

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    AI Agent 协作的层次模型                               │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  Level 1: 代码生成工具 (Code Generator)                                  │
│  ────────────────────────────────────────                                │
│  用户: "帮我写一个CoT的prompt"                                           │
│  AI:   [直接给代码]                                                      │
│  结果: 完成任务，但学到了什么？❌                                         │
│                                                                          │
│  Level 2: 问题解决伙伴 (Problem Solver)                                  │
│  ────────────────────────────────────────                                │
│  用户: "分析一下为什么我的CoT不工作"                                     │
│  AI:   [分析问题 + 提供解决方案]                                         │
│  结果: 解决问题，理解了一些原因 ✓                                        │
│                                                                          │
│  Level 3: 思考导师 (Thinking Mentor)                                     │
│  ────────────────────────────────────────                                │
│  用户: "解释CoT的核心原理，然后帮我设计对比实验"                         │
│  AI:   [解释原理 + 设计框架 + 引导思考]                                  │
│  结果: 深度理解，获得可迁移的知识 ✓✓                                     │
│                                                                          │
│  Level 4: 学习加速器 (Learning Accelerator)           ← 目标状态         │
│  ────────────────────────────────────────                                │
│  用户: "帮我理解这个概念，提出问题引导我思考，设计实验让我验证"          │
│  AI:   [概念解释 + 思考问题 + 实验设计 + 结果分析框架]                   │
│  结果: 主动学习，建立完整的知识体系 ✓✓✓                                  │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

### 🛠️ 实践方法论

#### 1. 三阶段协作模型

```
阶段1: 理解 (Understand)
┌─────────────────────────────────────────────────────────────┐
│  提问模板:                                                   │
│  - "解释[概念]的核心原理，用简单的类比"                        │
│  - "为什么[技术]在[场景]下有效/无效？"                        │
│  - "[概念A]和[概念B]的本质区别是什么？"                       │
│                                                              │
│  要点: 不要急于获得代码，先建立概念理解                        │
└─────────────────────────────────────────────────────────────┘
         ↓
阶段2: 设计 (Design)
┌─────────────────────────────────────────────────────────────┐
│  提问模板:                                                   │
│  - "基于这个理解，设计一个实验来验证[假设]"                    │
│  - "有哪些可能的方案？各自的优缺点是什么？"                    │
│  - "如何评估[方案]的效果？需要什么指标？"                      │
│                                                              │
│  要点: 让AI帮你设计，但你来决策                               │
└─────────────────────────────────────────────────────────────┘
         ↓
阶段3: 实现 (Implement)
┌─────────────────────────────────────────────────────────────┐
│  提问模板:                                                   │
│  - "基于我们的设计，实现[具体功能]"                           │
│  - "代码中的[部分]是如何体现[原理]的？"                        │
│  - "如何改进这个实现？"                                       │
│                                                              │
│  要点: 理解代码背后的设计决策                                 │
└─────────────────────────────────────────────────────────────┘
```

#### 2. 反馈循环

```
实验 → 观察 → 假设 → 验证 → 学习
 ↑                           │
 └───────────────────────────┘

与AI协作的关键问题:
- "实验结果和预期一致吗？为什么？"
- "这个结果告诉我们什么？"
- "基于这个学习，下一步应该尝试什么？"
```

#### 3. 知识固化

```
每次学习后，要求AI帮你:
1. 总结关键洞察 (Key Insights)
2. 提炼可迁移的原则 (Transferable Principles)
3. 记录常见陷阱 (Common Pitfalls)
4. 创建快速参考 (Quick Reference)
```

### 📝 本次任务的协作示例

```
你的请求:                                      协作级别
─────────────────────────────────────────────────────────
"思考chain of thought prompting 我应该如何思考"  │
"扮演顶尖的AI engineer，如何调整脚本设计实验"    │ Level 4
"能够让我更好地学习并理解chain of prompting"     │
─────────────────────────────────────────────────────────
                                                    ↓
AI的响应:
1. 分析现有代码的问题 (概念层面)
2. 提出科学的实验设计框架 (设计层面)
3. 提出思考问题引导深入理解 (学习层面)
4. 总结协作方法论 (元认知层面)
5. 实现改进后的代码 (实现层面)
```

---

## CoT的变体与进阶

### 🔄 CoT家族

```
Chain of Thought (CoT)
├── Zero-shot CoT
│   └── "Let's think step by step"
│
├── Few-shot CoT
│   └── 带推理过程的示例
│
├── Self-Consistency (SC)
│   └── 多次采样 + 多数投票
│   └── 见 self_consistency_prompting.py
│
├── Tree of Thoughts (ToT)
│   └── 探索多条推理路径
│   └── 选择最佳路径
│
├── Graph of Thoughts (GoT)
│   └── 更复杂的推理结构
│
└── Reflexion
    └── 自我反思和修正
    └── 见 reflexion.py
```

### 与其他Week1技术的关系

| 技术 | 与CoT的关系 |
|------|------------|
| **K-shot** | CoT可以和K-shot结合，形成Few-shot CoT |
| **Self-Consistency** | 多次运行CoT，投票选择最佳答案 |
| **Reflexion** | CoT的结果可以用于反思和迭代改进 |
| **RAG** | 检索到的知识可以融入CoT的推理过程 |
| **Tool Calling** | CoT中可以调用外部工具验证中间步骤 |

---

## 总结检查清单

### ✅ 学习目标

- [ ] 理解CoT的核心原理（为什么中间步骤有帮助）
- [ ] 区分CoT和答案泄露
- [ ] 掌握不同CoT变体（Zero-shot, Few-shot, Structured）
- [ ] 能够设计科学的对比实验
- [ ] 理解CoT的适用场景和局限性

### ✅ 实践能力

- [ ] 能够为数学推理问题设计有效的CoT prompt
- [ ] 能够评估CoT的效果（不仅看答案，还看推理质量）
- [ ] 能够迭代改进prompt

### ✅ 元认知

- [ ] 理解如何与AI Agent高效协作学习
- [ ] 能够提出引导性问题促进深入理解
- [ ] 能够从实验中提取可迁移的原则

---

**版本：** 1.0  
**最后更新：** 2025-12-07  
**关联文件：** `week1/chain_of_thought.py`
