# AI Engineering 核心原则

> **成为更好的 AI Engineer 的关键洞察**
>
> 本文档总结了让 AI 系统更可靠、更高效、更可维护的十大设计原则。

---

## 📐 原则体系架构

```
┌─────────────────────────────────────────────────────────┐
│                    元层：持续改进                        │
│              (原则十：PDCA 反馈循环)                     │
└────────────────────────┬────────────────────────────────┘
                         │
        ┌────────────────┼────────────────┐
        │                │                │
┌───────┴────────┐ ┌─────┴──────┐ ┌──────┴────────┐
│    认知层      │ │   设计层    │ │    执行层      │
│ ┌────────────┐ │ │ ┌────────┐  │ │ ┌──────────┐  │
│ │原则一：    │ │ │ │原则三：│  │ │ │原则五：  │  │
│ │认知负载    │ │ │ │Prompt  │  │ │ │并行执行  │  │
│ └────────────┘ │ │ │分层    │  │ │ └──────────┘  │
│ ┌────────────┐ │ │ ├────────┤  │ │ ┌──────────┐  │
│ │原则二：    │ │ │ │原则四：│  │ │ │原则六：  │  │
│ │Token效率   │ │ │ │验证驱动│  │ │ │ROI量化  │  │
│ └────────────┘ │ │ └────────┘  │ │ └──────────┘  │
└────────────────┘ └──────┬──────┘ └───────────────┘
                         │
                  ┌──────┴──────┐
                  │   沟通层     │
                  │ ┌──────────┐ │
                  │ │原则七：  │ │
                  │ │问题-方案 │ │
                  │ │框架      │ │
                  │ └──────────┘ │
                  └───────────────┘
```

---

## 一、认知负载理论

### 核心思想

**人类和 AI 都有"认知预算"**，需要渐进式提供信息以降低理解成本。

### 信息密度金字塔

```
                    ▲
                   ╱ ╲                    纯代码文件
                  ╱   ╲                   100% 密度
                 ╱  3  ╲                  需要逐行解析
                ╱  层  ╲                 适合深度学习
               ╱       ╲
              ╱─────────╲                摘要文档
             ╱    2     ╲                20% 密度
            ╱    层     ╲                可快速扫描
           ╱             ╲               适合概览
          ╱───────────────╲
         ╱       1         ╲             分层索引 (PROJECT_INDEX)
        ╱       层          ╲            5% 密度 + 指针
       ╱                     ╲           按需深入
      ╱───────────────────────╲          适合快速定位
```

### 三大设计原则

| 原则 | 核心机制 | 实践应用 |
|:----:|:---------|:---------|
| **渐进式揭示** | 从概览到细节 | Metadata → Structure → Details |
| **按需深入** | 只读需要的部分 | 先读索引，定位后读具体文件 |
| **多级缓存** | 避免重复计算 | PROJECT_INDEX 作为 L1 缓存 |

### ✅ 好的做法 vs ❌ 差的做法

```yaml
❌ 差的做法：一次性加载所有信息
"读取所有代码文件并分析..."
成本：58,000 tokens/会话

✅ 好的做法：渐进式加载
"1. 读取 PROJECT_INDEX 了解结构 (3,000 tokens)
 2. 定位相关文件
 3. 只读取需要的文件
 4. 按需深入更多文件"
成本：3,000 tokens/会话 (节省 94%)
```

---

## 二、Token 效率优化的数学原理

### 核心公式

```
Token Budget = Context Window - System Prompt - Input - Output
```

### 索引策略的 ROI 模型

```
无索引成本：
Cost_no_index = Sessions × Token_full_codebase

有索引成本：
Cost_with_index = Token_creation + Sessions × Token_index

盈亏平衡点：
Token_creation = Sessions × (Token_full - Token_index)
Sessions = Token_creation / (Token_full - Token_index)
```

### 实际案例：本项目的 ROI

```
项目数据：
- Token_full = 58,000 (完整代码库)
- Token_index = 3,000 (PROJECT_INDEX)
- Token_creation = 2,000 (一次性成本)

盈亏平衡计算：
Sessions = 2000 / (58000 - 3000)
         = 2000 / 55000
         ≈ 0.036

结论：仅需 1 次会话即可收回成本！
```

### 💰 10 次会话的累积节省

```
无索引：10 × 58,000 = 580,000 tokens
有索引：2,000 + (10 × 3,000) = 32,000 tokens
节省：548,000 tokens (94.5%)
```

### 四种优化策略

| 策略 | Token 节省 | 适用场景 | 实施难度 |
|:----:|:----------|:---------|:--------:|
| **创建索引** | 90-95% | 大型项目 | 低 |
| **分模块索引** | 85-90% | 模块化项目 | 中 |
| **增量更新** | 持续优化 | 频繁变更 | 中 |
| **压缩冗余** | 10-20% | 文档多的项目 | 低 |

---

## 三、Prompt Engineering 分层思维

### 四层架构模型

```
┌──────────────────────────────────────────────────────────────┐
│ Layer 1: 元指令 (Persona)                                    │
│ ─────────────────────────────────────────────────────────── │
│ 示例："你是一个..." "你的任务是..."                             │
│ 目的：建立 AI 的角色认知                                       │
│ 验证：AI 是否表现出预期行为                                    │
├──────────────────────────────────────────────────────────────┤
│ Layer 2: 结构化指令 (Process)                                │
│ ─────────────────────────────────────────────────────────── │
│ 示例：Phase 1 → Phase 2 → Phase 3                           │
│ 目的：定义执行流程                                             │
│ 验证：AI 是否按步骤执行                                        │
├──────────────────────────────────────────────────────────────┤
│ Layer 3: 模板指令 (Output)                                   │
│ ─────────────────────────────────────────────────────────── │
│ 示例：{field} 填充具体内容                                     │
│ 目的：确保输出格式一致性                                        │
│ 验证：输出是否符合模板                                         │
├──────────────────────────────────────────────────────────────┤
│ Layer 4: 验证指令 (Quality)                                  │
│ ─────────────────────────────────────────────────────────── │
│ 示例：检查清单 [ ] [ ] [ ]                                    │
│ 目的：激发自我审查                                             │
│ 验证：AI 是否检查自己的输出                                    │
└──────────────────────────────────────────────────────────────┘
```

### 从下往上的设计流程

```
┌─────────────────────────────────────────────┐
│ 4. 添加验证机制 (Layer 4)                    │
│    问题："如何确保质量？"                     │
│    → 检查清单、质量标准、验证触发器           │
└─────────────────┬───────────────────────────┘
                  │
┌─────────────────┴───────────────────────────┐
│ 3. 定义角色认知 (Layer 1)                    │
│    问题："谁最适合执行这个任务？"             │
│    → Persona、行为模式、约束条件              │
└─────────────────┬───────────────────────────┘
                  │
┌─────────────────┴───────────────────────────┐
│ 2. 定义执行步骤 (Layer 2)                    │
│    问题："如何生成这个输出？"                 │
│    → 任务分解、阶段划分、验证门控             │
└─────────────────┬───────────────────────────┘
                  │
┌─────────────────┴───────────────────────────┐
│ 1. 定义输出模板 (Layer 3)                    │
│    问题："我想要什么样的输出？"               │
│    → Markdown/JSON 结构、占位符、视觉层级     │
└─────────────────────────────────────────────┘
```

### 每层的关键问题

| Layer | 核心问题 | 输出 | 验证方法 |
|:-----:|:---------|:-----|:---------|
| **L1: Persona** | 谁来执行？ | 角色定义 | AI 行为是否符合角色 |
| **L2: Process** | 如何执行？ | 执行步骤 | AI 是否按步骤执行 |
| **L3: Output** | 输出什么？ | 输出模板 | AI 输出是否符合模板 |
| **L4: Quality** | 质量如何？ | 验证清单 | AI 是否自我检查 |

---

## 四、验证驱动的 Prompt 设计

### 核心思想

**让 AI 自我验证**，而不是被动接受输出。

### 验证触发器模式

```markdown
## Quality Validation

**Completeness Checks**:
- [ ] All entry points identified?
- [ ] Core modules documented?

**Quality Checks**:
- [ ] Index size < 5KB?
- [ ] All paths are valid?

**Usability Checks**:
- [ ] Human-readable format?
- [ ] Machine-parseable format?
```

### 四种验证模式

| 模式 | 触发词 | 效果 | 示例场景 |
|:----:|:------|:-----|:---------|
| **检查清单** | `[ ]` | 二元确认 | 文件完整性检查 |
| **阈值验证** | `< 5KB` | 可量化标准 | Token 预算控制 |
| **存在性检查** | `All ...?` | 完整性验证 | 入口点覆盖 |
| **用户视角** | `Human-readable` | 可用性检查 | 文档质量 |

### ✅ 带验证的 Prompt 模板

```yaml
任务：创建 PROJECT_INDEX

步骤：
1. 扫描代码库结构
2. 提取关键元数据
3. 生成索引文件

验证检查：
- [ ] 文件大小 < 5KB
- [ ] 所有关键路径已包含
- [ ] 格式符合 Markdown 规范
- [ ] 人类可读且机器可解析
- [ ] 所有链接有效
```

---

## 五、并行执行模式

### 核心思想

**激活并发思维**，充分利用 AI 工具的并行能力。

### 并行执行示例

```markdown
**Parallel analysis** (5 concurrent Glob searches):

1. Code Structure: src/**/*.py
2. Documentation: docs/**/*.md
3. Configuration: *.{toml,yaml,json}
4. Tests: tests/**/*.py
5. Scripts: scripts/**/*

Phase 2: Merge and analyze results
```

### 并行设计四要素

| 要素 | 作用 | 示例 |
|:----:|:-----|:-----|
| **数量明确** | 告知并行度 | `5 concurrent` |
| **任务独立** | 确保可并行 | 5 个独立的 Glob 搜索 |
| **结果合并** | 指定合并方式 | `Extract metadata → Phase 2` |
| **同步点** | 定义等待点 | `Phase 2: Merge results` |

### ✅ 好的做法 vs ❌ 差的做法

```yaml
❌ 顺序执行：浪费时间
"1. 读取 src/
2. 读取 tests/
3. 读取 docs/"
耗时：3 × 时间单位

✅ 并行执行：3 倍速度
"并行读取（3 个并发）：
- src/**/*.py
- tests/**/*.py
- docs/**/*.md
然后合并结果"
耗时：1 × 时间单位（节省 66%）
```

---

## 六、ROI 量化的说服力

### 核心思想

**用数字说话**，让投入产出比清晰可见。

### ROI 计算模板

```markdown
## Cost-Benefit Analysis

**Investment**:
- One-time: {tokens} tokens
- Per-session: {tokens} tokens

**Baseline**:
- Without solution: {tokens} tokens/session

**Break-even**: {N} sessions

**Projected Savings**:
- {N} sessions: {tokens} tokens
- {N} sessions: {tokens} tokens
```

### 实际案例：PROJECT_INDEX 的 ROI

```
投入：
- 一次性创建成本：2,000 tokens
- 每次会话读取成本：3,000 tokens

基线：
- 不使用索引：58,000 tokens/会话

盈亏平衡点：
- 1 次会话即可收回成本

100 次会话的累积节省：
- 无索引：100 × 58,000 = 5,800,000 tokens
- 有索引：2,000 + (100 × 3,000) = 302,000 tokens
- 节省：5,498,000 tokens (94.8%)
```

### 为什么数字有效

| 心理效应 | 技术目的 |
|:---------|:---------|
| 投资回报率可视化 | 让 AI 理解"为什么值得" |
| 复利效应展示 | 强调一次性成本的合理性 |
| 盈亏平衡点明确 | 给出清晰的决策阈值 |
| 数字精确性高 | 建立信任和可量化性 |

---

## 七、问题-解决方案框架

### 核心思想

**结构化表达问题**，让解决方案更有说服力。

### 标准模板

```markdown
## Problem Statement
**Current**: [描述当前低效状态，量化成本]
**Target**: [描述目标状态，量化改进]
**Impact**: [对用户的影响]

## Solution Approach
[详细说明解决方案]

## Expected Outcomes
- [定量指标 1]
- [定量指标 2]
```

### 实际案例

```markdown
## Problem Statement
**Current**: 每次会话读取完整代码库 → 58,000 tokens
**Target**: 读取 PROJECT_INDEX → 3,000 tokens (94% 减少)
**Impact**: 更快的上下文加载，更低的成本

## Solution Approach
创建分层索引：
1. PROJECT_INDEX.md (L1: 3KB)
2. Week-specific indices (L2: 按需)
3. Full source (L3: 深入时)

## Expected Outcomes
- Token 使用减少 94%
- 上下文加载速度提升 10 倍
- 会话成本降低 95%
```

---

## 八、模板化输出的约束设计

### 核心思想

**用占位符和约束**，确保 AI 输出格式一致。

### 占位符类型

| 类型 | 格式 | 约束程度 | 示例 |
|:----:|:-----|:--------:|:-----|
| 自由文本 | `{field}` | 无约束 | 项目描述 |
| 单行文本 | `{field} (1-line)` | 强约束 | 一句话总结 |
| 列表 | `{list}` | 格式约束 | 依赖项列表 |
| 路径 | `{path}` | 格式约束 | 文件路径 |
| 可选 | `{optional}` | 无约束 | 补充信息 |

### 约束设计示例

```markdown
### Module: {name}
- Path: {path}                    # 自由文本
- Exports: {list}                 # 列表格式
- Purpose: {1-line description}   # 单行约束
- Dependencies: {optional}        # 可选字段
- Author: {name}                  # 自由文本
- License: {MIT|Apache|GPL}       # 枚举约束
```

### 约束设计四原则

1. **明确约束类型**：单行、列表、枚举、可选
2. **使用占位符**：`{field}` 清晰标记可替换部分
3. **提供示例**：`{value} → 实际值` 展示预期
4. **视觉区分**：用不同格式标记不同类型

---

## 九、上下文触发的导航设计

### 核心思想

**为 AI 提供导航指令**，让它在正确的时机做正确的事。

### AI 友好的导航系统

```json
{
  "navigation": {
    "for_ai_agents": [
      "会话开始 → Read PROJECT_INDEX.md first",
      "特定周任务 → Use /week command",
      "代码变更 → Use code-reviewer agent",
      "测试需求 → Use /test-week command",
      "需要帮助 → Read CLAUDE.md"
    ]
  }
}
```

### 触发模式映射表

| 触发条件 | 动作 | 目的 | 预期效果 |
|:--------:|:-----|:-----|:---------|
| 会话开始 | Read PROJECT_INDEX | 建立结构认知 | 快速理解项目架构 |
| 特定周任务 | Use /week | 获取周上下文 | 聚焦相关内容 |
| 代码变更 | Use code-reviewer | 质量门控 | 提前发现问题 |
| 测试需求 | Use /test-week | 执行测试 | 验证功能正确性 |
| 文档编写 | Use /sc:document | 生成文档 | 保持文档一致性 |

### 设计三原则

1. **触发条件明确**：何时做什么（if-then 关系）
2. **动作具体可执行**：调用哪个命令/代理
3. **预期效果清晰**：为什么这样做（价值主张）

---

## 十、持续改进的反馈循环

### 核心思想

**用 PDCA 循环**，持续优化 Prompt 质量。

### PDCA 在 Prompt Engineering 中的应用

```
┌─────────────────────────────────────────────┐
│ Plan (计划)                                 │
│ ├─ 定义 Prompt 目标                         │
│ ├─ 设计输出模板                             │
│ └─ 规划验证机制                             │
└─────────────────┬───────────────────────────┘
                  │
┌─────────────────┴───────────────────────────┐
│ Do (执行)                                   │
│ ├─ 运行 Prompt                              │
│ ├─ 收集输出                                 │
│ └─ 记录异常                                 │
└─────────────────┬───────────────────────────┘
                  │
┌─────────────────┴───────────────────────────┐
│ Check (检查)                                │
│ ├─ 对比预期与实际                           │
│ ├─ 分析差异原因                             │
│ └─ 识别改进点                               │
└─────────────────┬───────────────────────────┘
                  │
┌─────────────────┴───────────────────────────┐
│ Act (改进)                                  │
│ ├─ 调整 Prompt                              │
│ ├─ 更新模板                                 │
│ └─ 优化验证                                 │
└─────────────────────────────────────────────┘
         │
         └──────► 回到 Plan (下一轮循环)
```

### Prompt 质量检查清单

```markdown
## Prompt Quality Checklist

**Clarity (清晰度)**:
- [ ] 目标明确？AI 知道"成功是什么样"
- [ ] 约束清晰？没有歧义
- [ ] 示例充分？有正例和反例

**Structure (结构)**:
- [ ] 逻辑分层？Persona → Process → Output → Quality
- [ ] 步骤合理？每个阶段可验证
- [ ] 流程清晰？有明确的输入输出

**Validation (验证)**:
- [ ] 有验证机制？检查清单或阈值
- [ ] 质量标准明确？可量化指标
- [ ] 错误处理完善？异常情况有预案

**Efficiency (效率)**:
- [ ] Token 优化？去除冗余表达
- [ ] 并行机会？独立任务可并行
- [ ] 缓存策略？可复用中间结果
```

---

## 实战检查清单

### 写 Prompt 前：5 问自查

```markdown
- [ ] 目标：AI 知道"成功是什么样"？
- [ ] 步骤：复杂任务是否分阶段？
- [ ] 输出：是否定义了期望格式？
- [ ] 验证：如何检查质量？
- [ ] ROI：是否量化了价值？
```

### 写 Prompt 后：5 查优化

```markdown
- [ ] 每层指令是否清晰？（Persona/Process/Output/Quality）
- [ ] 占位符是否明确？（{field} 约束）
- [ ] 验证机制是否完善？（检查清单）
- [ ] 并行机会是否利用？（Concurrent tasks）
- [ ] Token 使用是否优化？（去除冗余）
```

---

## 相关资源

- 📄 [索引生成分析](./01-index-repo-analysis.md)
- 📄 [PROJECT_INDEX 使用指南](../project-patterns/01-project-index-usage.md)
- 📄 [学习 Prompts 集合](../learning-prompts/README.md)
- 📄 [子代理系统详解](./subagent-system.md)
- 📄 [SuperClaude 架构](./superclaude-architecture.md)
- 📄 [TDD 核心原则](./tdd-first-principles.md)

---

**最后更新**: 2026-01-08
**维护者**: CS146S Course Team
**反馈**: GitHub Issues
