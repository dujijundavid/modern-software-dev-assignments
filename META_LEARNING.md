# META_LEARNING.md

## 🌀 AI 工程师能力提升系统

**核心理念**：不是更快完成任务，而是持续提升能力层级 —— 从工具使用者到系统架构师。

> **关键转变**：从"优化任务效率"到"提升工程能力"

---

## 🎯 核心目标

```
❌ 错误目标：如何用 AI 工具更快完成任务？
✅ 正确目标：如何通过 AI 协作提升工程能力？

传统方式：
  Task → Use Tool → Done → Forget
  问题：你变成了"工具操作员"

能力提升方式：
  Task → Identify Level → Deliberate Practice → Reflect on Capability → Level Up
  目标：你变成了"系统设计者"
```

---

## 📖 快速理解（3 分钟）

### AI 工程师能力金字塔

```
┌─────────────────────────────────────────────────────────────┐
│ L4: 系统架构师 (Systems Architect)                          │
│ ────────────────────────────────────────────────────────── │
│ 核心能力：平台化系统设计（治理/观测/扩展）                   │
│ 标志：系统可多人用；插件化扩展点清晰                        │
│ 时间视野：1+ 月，影响整个团队                               │
└─────────────────────────────────────────────────────────────┘
         ↑ 能设计新系统
┌─────────────────────────────────────────────────────────────┐
│ L3: 流程自动化者 (Workflow Automator)                       │
│ ────────────────────────────────────────────────────────── │
│ 核心能力：系统化重复工作（契约/参数/失败处理）               │
│ 标志：交付可复用工件，并稳定复用 3+ 次                       │
│ 时间视野：1-4 周，影响个人效率                              │
└─────────────────────────────────────────────────────────────┘
         ↑ 能识别瓶颈并设计自动化
┌─────────────────────────────────────────────────────────────┐
│ L2: 协作工程师 (Collaborative Engineer)                     │
│ ────────────────────────────────────────────────────────── │
│ 核心能力：工程闭环协作（验收标准 + 验证）                   │
│ 标志：能定义 DoD，并用测试/清单验证交付                      │
│ 时间视野：1 周，完成具体任务                                │
└─────────────────────────────────────────────────────────────┘
         ↑ 能把一次交付做对
┌─────────────────────────────────────────────────────────────┐
│ L1: 工具使用者 (Tool User)                                  │
│ ────────────────────────────────────────────────────────── │
│ 核心能力：熟练使用现有 AI 工具                              │
│ 标志：能跑通结果，并复现自己的工作流                         │
│ 时间视野：几小时，完成单个任务                              │
└─────────────────────────────────────────────────────────────┘
```

### 重要校准：层级不是由工具决定的

当你拥有 Cursor、Claude Code（含 subagents）、Super Claude 等强大工具时，**最容易发生的错误**是：把“工具把事做出来了”误以为“我具备更高层级的能力”。  
这个体系的分层应按**工程责任 + 可验证工件**来判定，而不是按“我用了什么工具”。  

**一眼判别（最小对比）**：
- L1：能把一个明确任务**跑出结果**（会用工具、能读改代码、能复现流程）
- L2：能对一次交付负责：把需求写成**验收标准**，并用测试/检查清单把结果**验证出来**
- L3：能把一类重复工作做成**可复用系统**（输入/输出契约 + 参数化 + 失败处理 + 复用次数）
- L4：能把多个自动化组合成**可扩展平台**（可治理/可观测/可扩展/多人可用）

### 实际案例：能力层级差异

**场景**：实现一个 Notes API 的前端界面

```
L1 做法（工具使用者）：
  "帮我用 Lovable 生成前端"
  → 工具生成代码 (2 分钟)
  → 完成任务 ✓
  → 学到了什么？只是知道了 Lovable 能用
  
L2 做法（协作工程师）：
  "这是需求/约束/验收标准（页面、状态、错误处理、性能）。请给我 2-3 个方案对比并选择一个实现；同时给出验证清单/基础测试策略。"
  → AI 输出：方案权衡 + 实现步骤 + 验收检查清单
  → 我做：评审 + 跑验证 + 迭代修正
  → 学到了：如何把“问 AI”变成可验证交付
  
L3 做法（流程自动化者）：
  观察："我每周都要为新 API 创建前端"
  → 设计：前端生成模板（输入：OpenAPI + UI 规范；输出：页面/组件/测试骨架）
  → 实现：命令/脚手架 + 参数化 + 失败降级
  → 学到了：如何把一类交付做成系统
  
L4 做法（系统架构师）：
  思考："如何让团队持续生成高质量前端？"
  → 设计：schema → UI/测试映射 + 评估回归 + 插件机制
  → 实现：多代理编排 + 观测/权限/版本治理
  → 学到了：平台化系统设计与治理
```

**关键洞察**：同样的任务，不同层级的人学到的东西完全不同。

---

## 🧭 能力层级详解

### L1: 工具使用者

**定义**：能熟练驱动现有 AI 工具与 IDE 工作流，把一个明确的小任务快速跑通（“能跑出结果”）。关注点是速度与工具熟练度，而不是复杂工程闭环。

**能力标志**：
- ✅ 能把问题拆成可执行步骤，并提供足够上下文（文件/日志/命令）
- ✅ 能读懂/运行/小幅修改 AI 生成代码，让它通过基本运行与编译
- ✅ 能复现自己的工作流（prompt、命令、环境），并快速定位明显错误
- ✅ 能区分“要结果” vs “要学习/可复用”，并选择合适路径

**典型任务**：
- 用 Claude Code/Cursor 生成脚手架或组件并跑起来
- 让 AI 解释/总结现有代码，快速定位入口与依赖
- 修复编译错误、类型错误、简单的 failing test
- 写/改一个小脚本自动化局部重复操作（一次性也可以）

**晋级条件 (L1 → L2)**：
- [ ] 能把需求写成**验收标准/Definition of Done**（不依赖“感觉完成了”）
- [ ] 能制定并执行**验证方式**（测试、检查清单、回归步骤）
- [ ] 能独立写出工程化 prompt：Persona → Process → Template → Validation（含验收与验证）
- [ ] 能在需求变化时稳定迭代：能解释差异、能定位原因、能把改动控制在合理范围
- [ ] 能判断何时不用 AI（或换工具/换流程）以保证正确性

**时间投入**：1-2 周熟悉工具

**系统影响** (Meadows):
```
核心能力: Tool Usage
放大效应: 无（基础层，不放大其他能力）
被放大效应:
  ← 被 L2 工程闭环协作放大（更好的上下文/验收/验证 → 更好的工具使用）
  ← 被 L3 Automation 放大（知道什么可自动化）
网络效应: 工具知识是所有上层能力的基础
```

**Job-to-be-Done: 何时练习 L1？** (Christensen):
```
核心问题: "快速完成具体任务"

触发条件:
  🔴 我需要快速完成一个明确的小任务（如生成一个函数）
  🔴 不关心长期复用，只求现在搞定
  🔴 任务复杂度低，我只需要知道"怎么用工具"

成功信号:
  ✅ 任务在几分钟内完成
  ✅ 我学会了如何使用这个工具/功能

何时停止:
  ⛔ 我发现自己重复使用同样的模式
  ⛔ 我开始需要明确验收/测试来保证质量
  ⛔ 我开始思考"这应该可以自动化"
  → 考虑进入 L2
```

---

### L2: 协作工程师

**定义**：对一次交付的工程闭环负责：需求澄清→方案权衡→实现→验证→迭代。AI 是协作者，你是负责人（对正确性、可维护性、可验证性负责）。

**能力标志**：
- ✅ 能把目标写成清晰的约束与验收标准（DoD）
- ✅ 能写/调整结构化 prompt，让 AI 输出可控（包含验证要求）
- ✅ 能做方案权衡（复杂度/性能/维护成本），并解释为什么这样选
- ✅ 能评估并修正 AI 输出（Code Review + 跑验证 + 定位缺陷）
- ✅ 能把大任务拆成可交付切片（分阶段交付，避免一次性大改）

**典型任务**：
- 端到端交付一个功能（含测试、文档、回归步骤）
- 用 AI 辅助实现 API/前端/脚本，但你定义接口与验收标准
- 让 AI 生成测试用例/测试策略并落地运行
- 用 AI 做 code review + 安全检查，然后修正并解释原因

**晋级条件 (L2 → L3)**：
- [ ] 能识别重复性任务并量化成本（"这个任务我每周做 3 次，每次 20 分钟"）
- [ ] 能把任务抽象成输入/输出契约（可写成 README/配置 schema）
- [ ] 创建了至少 1 个可复用自动化（脚本/命令/模板/CI job），具备参数化与失败处理
- [ ] 自动化被复用 ≥3 次（你自己或他人）且维护成本可控
- [ ] 自动化有最基本的质量门槛（测试/示例/验收清单）

**时间投入**：2-4 周的刻意练习

**⚠️ 常见陷阱**：
- 过度依赖 AI，不思考设计
- 只求快速完成，不提炼模式
- 把 AI 当"代码生成器"而非"协作伙伴"
- 只写 prompt 不做验证（最终靠运气，不靠工程）

**系统影响** (Meadows):
```
核心能力: 工程闭环协作（清晰需求 + Prompt + 验收/验证）
放大效应:
  → L3 Automation: 稳定交付闭环 → 可固化为自动化
  → L4 System Design: 清晰契约/权衡 → 更好的系统设计
被放大效应:
  ← L1 Tool Knowledge: 更懂工具 → 更好的协作效率
  ← L3 Automation: 自动化实践 → 反哺更好的模板/验证
网络效应: 验收与验证清晰度决定 AI 协作可控性
```

**Job-to-be-Done: 何时练习 L2？** (Christensen):
```
核心问题: "与 AI 协作完成交付，并确保结果可验证"

触发条件:
  🔴 任务需要多轮对话才能完成
  🔴 我需要 AI 帮我做设计决策，不只是生成代码
  🔴 我发现 AI 的输出质量取决于我如何提问

成功信号:
  ✅ 验收标准被满足，并能用测试/检查清单验证
  ✅ 我能解释关键权衡与失败原因，而不是“碰巧跑通”
  ✅ 迭代成本可控（能小步改对，而不是推倒重来）

何时停止:
  ⛔ 我开始识别重复性任务
  ⛔ 我思考"如何让这个可复用"
  → 考虑进入 L3
```

---

### L3: 流程自动化者 🎯 [当前目标]

**定义**：把一类重复工作做成可复用系统：抽象输入/输出契约、参数化、失败处理与复用方式，让未来同类问题的边际成本显著下降。

**能力标志**：
- ✅ 本能地识别重复模式："这个我以后会再做"
- ✅ 能抽象任务为可配置的系统（契约清晰：输入/输出/约束）
- ✅ 能考虑边界情况、失败恢复与降级路径
- ✅ 能让自动化被自己/他人多次复用，并保持维护成本可控

**典型任务**：
- 创建测试/脚手架/评审的自动化命令或模板（含参数化与失败处理）
- 把 onboarding 的探索流程做成可重复的 playbook（入口→关键文件→验证路径）
- 构建质量门槛：可复用的检查清单/CI job/代码生成器

**核心思维转变**：
```
L2 思维："如何完成这个任务？"
L3 思维："这个任务的本质是什么？如何让它可复用？"

L2 思维："Lovable 生成了代码，完成！"
L3 思维："Lovable 生成代码的模式是什么？我能创建类似的生成器吗？"

系统思维版本 (Meadows):
L2 思维："这个任务完成了"
L3 思维："这个任务如何连接到我其他能力？"
         "这个自动化会放大什么？"
         "什么会放大这个自动化？"
```

**系统影响** (Meadows) ⭐:
```
核心能力: Workflow Automation

放大效应:
  → L2 工程闭环协作: 自动化模式 → 更好的模板 + 验收/验证
  → L4 System Design: 自动化实践 → 系统设计经验
  → 每个自动化让我的 prompt 更清晰（循环增强）

被放大效应:
  ← L2 工程闭环协作: 能清晰定义契约/验收并驱动实现
  ← L1 Tool Knowledge: 知道什么工具可自动化
  ← L2 协作经验: 知道哪些任务值得自动化

网络效应:
  每个自动化揭示新的自动化机会（递归增强）
  - 做了一个测试自动化 → 发现其他测试也能自动化
  - 做了一个部署自动化 → 发现 CI/CD 整个流程可优化

关键洞察: L3 是 L2 和 L4 之间的桥梁
  - L2 让我"知道"如何与 AI 协作
  - L3 让我"系统化"这些协作经验
  - 这为 L4 的系统设计打下实践基础
```

**Job-to-be-Done: 何时练习 L3？** (Christensen) ⭐:
```
核心问题: "停止重复做同样的工作"

触发条件:
  🔴 我发现自己做同样的任务 3 次以上
  🔴 我心里想"这里应该有更好的方法"
  🔴 我在重复性、低价值的工作上花时间
  🔴 我能量化这个任务的时间成本（频率 × 时间）

成功信号 (4 周目标):
  ✅ 识别了 5 个瓶颈（不是别人告诉我的，是我自己发现的）
  ✅ 构建了 3 个可复用自动化
  ✅ 每周节省 5+ 小时
  ✅ 每个自动化被复用 3+ 次

何时停止:
  ⛔ 我开始思考"如何让多个自动化协同工作" → 考虑 L4
  ⛔ 我需要设计跨组件的系统 → 考虑 L4
  ⛔ 我关心"其他人如何使用这个系统" → 考虑 L4

练习建议:
  - 20% 的任务用 L3 模式（刻意练习）
  - 80% 的任务继续用 L2 模式（保持效率）
  - 选择那些"我以后会再做"的任务作为 L3 练习对象
```

**每日检查清单** ⭐:
```yaml
今天我是否展现了 L3 能力？
- [ ] 识别了重复性任务？
- [ ] 量化了时间成本（频率 × 时间）？
- [ ] 设计了可复用方案（不是一次性的）并明确输入/输出契约？
- [ ] 考虑了失败恢复？
- [ ] 这个自动化被复用了吗？（或至少可被复用：文档/示例/参数就绪）

如果以上都是 Yes → 你在用 L3 思维
如果部分 Yes → 你在从 L2 向 L3 过渡
如果都 No → 你还在 L2 模式（这没问题！80% 任务应该这样）
```

**晋级条件 (L3 → L4)**：
- [ ] 设计了多个自动化可以组合使用（明确接口/契约）
- [ ] 考虑了自动化之间的协调问题（并发、冲突、版本兼容）
- [ ] 创建了可被他人复用的系统（文档化 + 低门槛接入）
- [ ] 引入治理能力：可观测性（日志/指标）、成本与权限、安全边界
- [ ] 能评估系统的可维护性、扩展性与团队采用成本

**时间投入**：1-2 个月的刻意练习

**关键实践**：
- 80% 任务快速完成（巩固 L2）
- 20% 任务深度思考（突破 L3）

---

### L4: 系统架构师

**定义**：把多个自动化/代理组合成可扩展平台：边界清晰、可治理、可观测、可扩展，并能被他人稳定使用。

**能力标志**：
- ✅ 能设计新的 MCP 服务器
- ✅ 能设计多代理协作系统
- ✅ 能评估系统的可维护性、可扩展性
- ✅ 设计的系统被多人使用
- ✅ 具备平台化工程能力：观测/权限/成本/版本/兼容/回归

**典型任务**：
- 设计类似 SuperClaude 的系统（编排 + 插件化 + 评估回归）
- 创建 MCP 服务器/工具层，提供稳定契约与可扩展点
- 设计团队级工作流平台：质量门槛、审计、安全与成本控制

**时间投入**：3-6 个月的深度实践

**系统影响** (Meadows):
```
核心能力: System Architecture

放大效应:
  → L3 Automation: 更好的系统 → 更多自动化机会
  → L2 工程闭环协作: 系统思维 → 更好的契约/验收与协作结构
  → 所有其他能力: 系统设计放大所有能力的价值

被放大效应:
  ← L3 Automation: 自动化实践积累的系统直觉
  ← L2 工程闭环协作: 清晰的需求/验收/权衡
  ← L1+L2+L3 的实践经验: 知道什么系统设计是有效的

网络效应:
  系统设计能力放大所有其他能力的价值
  - 好的系统设计让 L2 自动化更容易
  - 好的系统设计让 L3 协作更流畅
  - 系统是能力的"放大器"
```

**Job-to-be-Done: 何时练习 L4？** (Christensen):
```
核心问题: "设计可扩展的 AI 系统"

触发条件:
  🔴 我有多个自动化需要协同
  🔴 我需要设计被他人使用的系统
  🔴 我关心系统的可维护性、可扩展性
  🔴 我能评估不同架构的权衡

成功信号:
  ✅ 我设计的系统被多人使用
  ✅ 系统能优雅处理失败（回滚、重试）
  ✅ 新功能可以低成本添加
  ✅ 系统有清晰的扩展点

何时停止:
  ⛔ 达成你的系统架构目标
  ⛔ 转向下一个能力领域
```

---

## 🚀 能力提升循环（核心系统）

### 第一步：任务前 - 层级识别与目标设定

**每个任务开始前，先填写：**

```markdown
## 任务能力分析（增强版）

**任务名称**: [描述]
**背景/上下文**: [相关模块/文件/现状]

**验收标准 (Definition of Done)**:
- [ ] [可验证的结果 1]
- [ ] [可验证的结果 2]

**验证方式**:
- [ ] 测试：[`pytest`/`npm test`/集成测试] + 关键用例
- [ ] 静态检查/安全：[`ruff`/`eslint`/`typecheck`/基础安全检查]
- [ ] 手动回归：关键路径 + 边界/错误处理

**产出工件**:
- [ ] 代码/配置：[路径或模块名]
- [ ] 测试：[路径或用例说明]
- [ ] 文档/变更说明：[README/ADR/PR 描述]

**系统视角检查** (Meadows) ⭐:
1. 这个任务会连接到哪些其他能力？ [列出]
2. 它会放大什么？ [描述]
3. 什么会放大它？ [描述]
4. 这会创造什么网络效应？ [描述]

**任务目标是什么？**
- [ ] A. 快速完成任务（效率优先，80%）
- [ ] B. 提升能力（学习优先，20%）

**如果选 B，这个任务需要什么层级的能力？**
- [ ] L1: 工具使用（跑通结果，熟练驱动工具）
- [ ] L2: 协作工程（工程闭环：验收标准 + 验证）
- [ ] L3: 流程自动化（可复用系统：契约 + 参数化 + 失败处理）⭐
- [ ] L4: 系统架构（平台化：治理/观测/扩展/多人可用）

**我当前在哪一层？** [自评]

**这个任务能帮我提升到下一层吗？**
- 如果是 → 采用"刻意练习"模式
- 如果否 → 快速完成，巩固当前能力

**Job-to-be-Done 检查** (Christensen) ⭐:
- 我遇到的触发条件是：[列出具体触发点]
- 我期望的成功信号是：[列出可衡量结果]
- 何时停止这个目标：[明确停止条件]

**刻意练习计划**（如果目标是提升）：
**本次刻意练习只选 1-2 个突破点**: [例如：写 DoD；把重复任务抽成契约]

**执行动作**:
1. [动作 1（可执行）]
2. [动作 2（可执行）]

**成功证据**:
- [ ] [可验证证据：复用次数/测试通过/节省时间]

**失败与降级**:
- 如果卡住 → [降级方案：先做最小切片/先手工再抽象/先模板后自动化]
```

### 协作提示词模板（可直接复制）

#### L2：工程闭环 Prompt（Spec → Options → Implement → Validate）
```text
你是我的“协作工程师”。我会给你项目上下文与目标。请按顺序输出：
1) 澄清问题（仅缺失信息）
2) 2-3 个方案对比（含取舍）并推荐一个
3) 验收标准（Definition of Done）
4) 验证计划（测试/静态检查/手动回归）
5) 实施步骤（按最小可交付切片拆分）
6) 风险与回滚/降级策略
要求：所有输出必须可执行、可验证；不要只给“建议”，要给我可落地的 DoD 和验证路径。
```

#### L3：系统化 Prompt（Bottleneck → ROI → Contract → Failure → Compose）
```text
你是我的“自动化产品经理 + 工程师”。目标是把下面的重复工作做成可复用系统。
请按顺序输出：
1) 重复性与成本量化（频率 × 时间）+ ROI（多久回本）
2) 输入/输出契约（建议用 config/schema 表达）
3) 参数化设计（参数、默认值、可扩展点）
4) 失败模式与恢复/降级策略
5) 实现方案（目录结构、命令接口、最小 demo）
6) 验证方式（测试/示例/CI）与维护策略（版本/兼容）
要求：交付一个“能复用的工件”，而不是一次性脚本。
```

**关键决策**：

```
80% 的任务 → 选 A（快速完成）
  目的：巩固当前能力，保持效率
  
20% 的任务 → 选 B（能力提升）
  目的：突破到下一层级
  关键：识别哪些任务是那关键的 20%
```

---

### 第二步：任务中 - 刻意练习

根据目标层级，采用不同的执行方式：

| 目标 | 执行方式 | AI 协作模式 | 成功标准 |
|------|---------|------------|---------|
| **巩固 L1** | 快速使用工具 | AI 作为执行者 | 结果可跑通 |
| **提升到 L2** | 先写验收标准再执行 | AI 作为协作者 | 交付可验证（验收+测试/检查） |
| **提升到 L3** | 强制抽象为可复用系统 | AI 作为苏格拉底导师 | 可复用工件落地（并可复用） |
| **提升到 L4** | 设计平台级系统 | AI 作为架构评审 | 可治理/可观测/可扩展 |

**L3 刻意练习清单**（当前重点）：

```markdown
## L3 刻意练习检查清单

在执行任务时，强制自己回答：

- [ ] **瓶颈识别**：这个任务我以后会重复吗？频率是多少？
- [ ] **成本量化**：如果不自动化，总成本是多少？（次数 × 时间）
- [ ] **ROI 评估**：自动化需要多久？多少次后收回成本？
- [ ] **接口设计**：输入是什么？输出是什么？
- [ ] **参数化**：哪些部分应该可配置？
- [ ] **失败处理**：什么情况下会失败？如何恢复？
- [ ] **组合性**：这个自动化能和其他自动化组合吗？
- [ ] **质量门槛**：如何验证自动化产物是对的？（测试/示例/CI）
- [ ] **复用与维护**：复用次数如何记录？维护成本/版本兼容如何控制？

如果以上问题你都能回答，你就在用 L3 思维。
```

---

### 第三步：任务后 - 能力提升反思（增强版）

**不再只问"完成了什么"，而是问"提升了什么能力"**

```markdown
## 能力提升反思（增强版）

**任务**: [描述]
**目标层级**: [L1/L2/L3/L4]

### 1. 能力使用分析
**我实际使用了哪一层的能力？**
[L1/L2/L3/L4]

**证据**：
[具体的行为证据]

### 2. 系统网络效应分析 (Meadows) ⭐
**网络连接**:
- 这个任务连接了哪些其他能力？ [列出]
- 新创建了哪些连接？ [描述]

**放大效应**:
- 这个任务放大了我的什么能力？ [描述]
- 什么能力放大了这个任务的执行？ [描述]

**网络密度**:
- 我的能力网络比之前更密集了吗？ [Yes/No]
- 哪些能力之间的连接更强了？ [列出]

### 3. Job-to-be-Done 回顾 (Christensen) ⭐
**触发条件验证**:
- [ ] 遇到了预期的触发条件？
- [ ] 有未预料的触发条件？

**成功信号验证**:
- [ ] 达到了预期的成功信号？
- [ ] 有未预期的收获？

**停止条件检查**:
- [ ] 应该停止当前层级，进入下一层？
- [ ] 应该继续巩固当前层级？

### 4. 能力突破检查
**我展现了下一层的能力吗？**
- [ ] 是：具体证据是什么？
- [ ] 否：为什么没有？被什么阻碍了？

**关键突破**（如果有）：
[描述任何"啊哈"时刻]

### 5. 对比分析
**传统做法 vs. 系统思维做法**：

| 维度 | 传统做法 | 系统思维做法 |
|------|---------|------------|
| 关注点 | [完成任务] | [构建能力网络] |
| 思考方式 | [线性] | [网络/放大] |
| 长期价值 | [有限] | [复合增长] |

### 6. 下次改进
**下次遇到类似任务，我会：**
1. [具体改进 1 - 系统视角]
2. [具体改进 2 - 网络连接]

**下次刻意练习**：
[哪个能力需要加强？如何加强？]
```

**示例反思**：

```markdown
## 能力提升反思：Week 5 多代理协作

**任务**: 实现 Warp 多代理并发执行
**目标层级**: L3（流程自动化）

### 1. 能力使用分析
**实际使用**: L2（协作工程）

**证据**：
- 我成功让多个代理并发运行
- 但没有设计可复用的编排模式
- 只是"完成了任务"

### 2. 系统网络效应分析 ⭐
**网络连接**:
- 连接了：L2 工程闭环协作（需要清晰契约/验收 + prompt 描述代理）
- 新创建了：无（没有形成可复用模式）

**放大效应**:
- 这个任务没有明显放大其他能力
- 被 L2 放大：我的需求/验收清晰度让代理能运行

**网络密度**:
- No，能力网络没有更密集
- 这是"一次性实现"，不是"可复用系统"

### 3. Job-to-be-Done 回顾 ⭐
**触发条件验证**:
- ✅ 遇到触发条件："我需要协调多个任务"
- ❌ 但没遇到："这个模式会重复"

**成功信号验证**:
- ❌ 没有达到："可复用的编排系统"
- ✅ 完成了具体任务

**停止条件检查**:
- ⛔ 还不应该停止，因为没有达到 L3 的成功信号
- 继续巩固 L2，寻找真正的 L3 触发条件

### 4. 能力突破检查
**我展现了 L3 能力吗？** ❌ 否

**阻碍**：
- 我关注"让它跑起来"，没想"如何让它可复用"
- 没有量化瓶颈成本
- 没有设计失败恢复机制

### 5. 对比分析

| 维度 | 我的做法 (L2) | L3 应该怎么做 |
|------|--------------|--------------|
| 关注点 | 完成任务 | 构建可复用系统 |
| 思考方式 | "如何让 3 个代理并发？" | "什么场景需要并发？如何参数化？" |
| 实现方式 | 硬编码 3 个代理名称 | 设计可配置的代理编排 DSL |
| 结果质量 | 只适用于这个任务 | 可复用到其他 N 个代理场景 |
| 长期价值 | 一次性收益 | 可复用，可组合 |

### 6. 下次改进
下次遇到类似任务：
1. 先用系统视角检查：这个模式会重复吗？
2. 设计时考虑：N 个代理的通用场景（不只是 3 个）
3. 实现时加入：失败检测和重试机制
4. 关注网络效应：这个设计能如何放大我的其他能力？

**下次刻意练习**：
找一个真正重复 3+ 次的任务，而不是一次性多代理任务
```

---

### 第四步：每周回顾 - 能力测量

**每周日，15 分钟能力检查**

```markdown
## Week X 能力检查

**当前层级**: L2
**目标层级**: L3

### L2 能力巩固（应该保持）
- [ ] 本周写了 X 个带 DoD+验证 的高质量 Prompt
- [ ] 交付一次通过率（满足验收+验证）：X/Y 任务达标
- [ ] 能预测 AI 输出质量

### L3 能力突破（重点关注）
- [ ] 识别了 X 个重复性任务
- [ ] 量化了 X 个瓶颈的成本
- [ ] 创建了 X 个自动化
- [ ] 自动化被复用了 X 次

### 能力提升证据
**本周最大突破**：
[描述一个关键的"啊哈"时刻]

**L3 思维的体现**：
[哪个任务中展现了"抽象""可复用""系统思维"]

### 能力差距分析
**为什么还没到 L3？**
- 阻碍 1: [具体的阻碍]
- 阻碍 2: [具体的阻碍]

**下周重点**：
[针对阻碍的具体练习计划]
```

---

## 🧠 AI 自动化思维框架（Mihail Eric Model）

### 核心原则：Build Systems, Not Just Code

**每个任务都要问的三个问题：**

```
🤔 Question 1: What's the bottleneck?
   哪里是重复性、低价值的工作？
   
   L2 回答："我需要重复写测试"
   L3 回答："我每周花 2 小时写测试，这是瓶颈"
   
🤔 Question 2: What's the leverage point?
   如何让这个自动化可复用、可组合？
   
   L2 回答："写一个脚本"
   L3 回答："设计一个测试生成器，可配置测试类型"
   
🤔 Question 3: How to compound value?
   这个自动化如何与其他自动化产生 1+1>3 的效果？

   L2 回答："暂时想不到"
   L3 回答："测试生成器 + 代码审查自动化 = 完整的质量保障流程"

🤔 Question 4: What does this amplify? ⭐ NEW (Meadows)
   这个自动化会放大我的哪些其他能力？

   L1 回答："没想过"
   L2 回答："没想过"
   L3 回答："这个自动化让我更懂 prompt，提高了 L2 能力"
   L4 回答："这个自动化系统放大了我的所有能力"

🤔 Question 5: What capabilities does this enable? ⭐ NEW (Meadows)
   这为哪些更高层的能力打下基础？

   L1 回答："不知道"
   L2 回答："暂时没想过"
   L3 回答："这个自动化经验让我能设计 L4 的系统"
   L4 回答："这个系统为未来所有能力提供基础设施"
```

### 自动化层级

```
Level 1: One-off Script    → 解决一次问题（L1-L2 能力）
Level 2: Reusable Function → 解决一类问题（L2-L3 能力）
Level 3: Composable System → 可以与其他自动化组合（L3 能力）
Level 4: Self-Improving    → 能够发现和优化自己的瓶颈（L4 能力）
```

**你的目标**：Always aim for Level 3+

### 设计自动化前的检查清单

```markdown
在实现自动化前，回答这些问题：

- [ ] **Is this task repeatable?** 
  频率：每周 X 次
  
- [ ] **Can this be parameterized?** 
  可配置的参数：[列出]
  
- [ ] **What's the input/output contract?**
  输入：[定义]
  输出：[定义]
  
- [ ] **How will this fail?**
  失败场景：[列出]
  恢复机制：[设计]
  
- [ ] **Can this run concurrently?**
  并发安全：[分析]
  
- [ ] **How does this compose with others?**
  可组合性：[描述]
```

---

## 📊 能力测量体系

### L2 → L3 晋级标准（详细）

**必须达到 4/6 项**：

| 能力指标 | 具体标准 | 验证方式 |
|---------|---------|---------|
| **瓶颈识别** | 能量化至少 3 个重复任务的成本 | 记录"任务 × 时间 × 频率" |
| **抽象设计** | 创建至少 2 个可复用自动化 | 自动化被复用 3+ 次 |
| **接口设计** | 能清晰定义输入/输出契约 | 文档中有明确的接口说明 |
| **失败处理** | 自动化有错误处理和回滚 | 代码中有 try-catch 和恢复逻辑 |
| **ROI 评估** | 能计算自动化的投资回报 | 记录"开发时间 vs 节省时间" |
| **系统思维** | 考虑了与其他自动化的组合 | 文档中描述了组合场景 |

### 能力成长追踪表

```markdown
## 我的能力矩阵

| 能力 | L1 | L2 | L3 | L4 | 当前 | 目标 | 达成日期 |
|------|----|----|----|----|------|------|----------|
| 工具使用 | ✅ | ✅ | - | - | L2 | - | 2025-12 |
| Prompt Engineering | ✅ | ✅ | - | - | L2 | L3 | ? |
| 瓶颈识别 | ✅ | 🟡 | ❌ | - | L2- | L3 | 2026-02 |
| 抽象设计 | ✅ | 🟡 | ❌ | - | L2- | L3 | 2026-02 |
| 系统思维 | ✅ | ❌ | ❌ | - | L1 | L3 | 2026-03 |
| 架构设计 | - | - | ❌ | ❌ | - | L4 | 2026-06 |

图例：
✅ 已掌握  🟡 部分掌握  ❌ 未掌握  - 不适用
```

### 能力提升事件日志

```markdown
## 能力提升事件记录

### 2026-01-04: Week 5 多代理协作
**事件**: 实现 Warp 多代理并发
**目标**: L3
**结果**: L2（未达到 L3）
**能力变化**:
- 瓶颈识别: L2- → L2 (开始意识到要量化)
- 抽象设计: L2- → L2- (仍然是一次性实现)
**关键洞察**:
"我学会了如何使用多代理，但还没学会如何设计多代理系统"
**下次改进**:
强制自己先回答："这个模式会重复吗？如何参数化？"

---

### [日期]: [任务]
**事件**: 
**目标**: 
**结果**: 
**能力变化**:
**关键洞察**:
**下次改进**:
```

---

## 🎯 智能决策树（增强版）

### 任务开始前的决策流程

```
┌─────────────────────────────────────┐
│ 问题 0: 这个任务的目标是什么？      │
└─────────────────────────────────────┘
           ↓
    ┌──────┴──────┐
    │             │
  快速完成     能力提升
  (80%)        (20%)
    │             │
    ↓             ↓
  使用决策树   使用刻意练习模式
  (选路径)     (识别层级)
```

### A. 快速完成模式（80% 任务）

**目标**：巩固当前能力，保持效率

**决策树**：

```yaml
问题 1：时间视野
  Short-term (< 1 周)    → Fast-Path: 直接生成
  Medium-term (1-4 周)  → Standard: 考虑可维护性
  Long-term (> 1 月)    → Investment: 设计系统

问题 2：重复频率
  一次性任务            → Fast-Path: 不要过度设计
  可重复模式            → Standard: 构建可复用组件
  基础设施             → Investment: 完善架构

问题 3：工具可用性
  专业工具存在          → Fast-Path: 优先使用工具
  只有通用 AI          → 评估复杂度
  低复杂度             → Fast-Path: 单文件
  高复杂度             → Standard: 分层架构
```

### B. 能力提升模式（20% 任务）

**目标**：突破到下一层级

**选择标准**：

```markdown
选择这 20% 的任务时，优先选择：

✅ 有明确重复模式的任务（练习 L3 抽象能力）
✅ 需要多步骤的任务（练习系统思维）
✅ 可以设计可复用方案的任务（练习接口设计）
✅ 你感到"这个以后会再遇到"的任务

❌ 避免选择：
- 完全新的、一次性的任务
- 时间压力极大的任务（会妥协质量）
- 依赖外部资源的任务（无法控制）
```

---

## 🎓 分层决策示例

### 案例 1：React 前端迁移（Week 5 作业）

```markdown
## 决策分析

**任务**: 为 Notes API 构建前端

**问题 0: 任务目标？**
- [X] A. 快速完成（80% 模式）
- [ ] B. 能力提升（20% 模式）

**原因**: Week 5 重点是多代理协作，前端是辅助任务

**决策树路径**:
- 时间视野: Short-term (本周提交)
- 重复频率: 低 (学习项目)
- 工具可用性: 有 (Lovable/v0)

**决策**: Fast-Path + Tool

**执行**:
1. 使用 Lovable 生成 (30 秒)
2. 或单文件实现 (2 分钟)

**避免**:
- ❌ 创建可复用组件库（L3 做法，但这不是那 20%）
- ❌ 完整的类型系统（过度工程）

**结果**: 2 分钟完成，而不是 30 分钟
**学到**: 快速原型工具的使用（巩固 L2）
```

### 案例 2：测试自动化（可选的 20% 任务）

```markdown
## 决策分析

**任务**: 为每周作业编写测试

**问题 0: 任务目标？**
- [ ] A. 快速完成
- [X] B. 能力提升（20% 模式）

**原因**: 
- 每周都要写测试（高重复性）
- 这是练习 L3 自动化设计的好机会

**层级识别**:
**这个任务需要 L3 能力**：
- 识别重复模式：每周测试结构类似
- 设计可复用系统：测试生成器
- 考虑失败处理：测试失败时的调试

**刻意练习计划**:

### L3 能力练习清单
- [ ] 量化成本："每周 8 次测试 × 15 分钟 = 2 小时"
- [ ] 设计接口：
  - 输入：API schema
  - 输出：pytest 测试文件
- [ ] 参数化：测试类型（CRUD/edge cases/security）
- [ ] 失败处理：测试生成失败时回退到模板
- [ ] 组合性：与 API 生成器组合使用

**执行**:
不直接写测试，而是：
1. 分析 Week 1-5 的测试模式
2. 设计测试生成 Slash Command
3. 实现可配置的测试模板
4. 文档化接口和使用方法

**结果**: 
- 花费 2 小时（vs 15 分钟手写）
- 但未来每周节省 1.5 小时
- 3 周后收回成本

**学到**: 
- L3 能力：抽象设计、ROI 评估
- 不是"完成任务"，是"设计系统"
```

### 案例 3：代码审查自动化（L3 → L4 过渡）

```markdown
## 决策分析

**任务**: 实现代码审查自动化

**问题 0: 任务目标？**
- [ ] A. 快速完成
- [X] B. 能力提升（挑战 L4）

**层级识别**:
**这个任务需要 L4 能力**：
- 多组件协作：linter + security scanner + AI reviewer
- 系统设计：如何编排这些组件？
- 可扩展性：如何添加新的检查器？

**刻意练习计划**:

### L4 能力练习清单
- [ ] 设计系统架构：组件、接口、数据流
- [ ] 考虑并发：多个检查器并行运行
- [ ] 考虑失败：某个检查器失败时的策略
- [ ] 考虑扩展：如何让他人添加新检查器
- [ ] 文档化：让他人能理解和使用

**执行**:
1. 设计插件架构（Checker Interface）
2. 实现编排器（Orchestrator）
3. 实现 3 个示例检查器
4. 写清晰的扩展文档

**学到**: 
- L4 能力：系统架构、可扩展性设计
- 从"自动化流程"到"设计平台"
```

---

## 🔄 模式库（自动积累）

### 模式记录格式

```markdown
## Pattern: [模式名称]

**触发条件**: [什么时候遇到这个模式]
**所需能力**: [L1/L2/L3/L4]
**解决方案**: [怎么做]
**工具**: [推荐工具]
**时间**: [耗时]
**复用次数**: [X 次]
**成功率**: [Y%]
**最后更新**: [日期]

**能力洞察**:
[这个模式教会了我什么能力]

**相关模式**:
- [链接到其他模式]
```

### 示例模式库

```markdown
## Pattern: 前端原型开发

**触发条件**:
- 需要为现有 API 快速构建 UI
- 不需要长期维护
- 演示或学习目的

**所需能力**: L2（协作工程）

**解决方案**:
1. 检查专业工具（Lovable, v0.dev）
2. 如果有，用工具生成（30s-2min）
3. 如果没有，单文件实现（2-5min）

**工具优先级**:
1. Lovable / v0.dev
2. Claude 单文件生成
3. 手工实现（仅当学习目的）

**时间**: 30s - 5min
**复用次数**: 8 次
**成功率**: 94%
**最后更新**: 2026-01-04

**能力洞察**:
- L2 能力：知道何时用工具而非手工
- 不是"L3 能力"因为这是工具使用而非系统设计

**相关模式**:
- [Pattern: API 优先设计](#pattern-api-first)

---

## Pattern: 测试生成自动化

**触发条件**:
- 重复编写相似结构的测试
- 测试模式可预测（CRUD API）
- 需要提升测试覆盖率

**所需能力**: L3（流程自动化）

**解决方案**:
1. 分析历史测试，提取模式
2. 设计参数化模板
3. 实现 Slash Command: `/generate-tests`
4. 输入：API schema
5. 输出：pytest 文件

**接口设计**:
```yaml
input:
  api_schema: path/to/openapi.json
  test_types: [crud, edge_cases, security]
output:
  test_file: tests/test_generated.py
```

**时间**: 
- 初次开发：2 小时
- 每次使用：30 秒
- 盈亏平衡：8 次使用

**复用次数**: 12 次
**成功率**: 89%
**最后更新**: 2026-01-04

**能力洞察**:
- L3 能力核心：ROI 思维、接口设计、可复用性
- 从"写测试"到"设计测试生成器"的思维跃迁

**失败案例**:
- Week 2: 生成的测试缺少边界情况（已改进）
- Week 4: Schema 解析失败（已添加验证）

**相关模式**:
- [Pattern: API 生成自动化](#pattern-api-generation)

---

## Pattern: 多代理编排

**触发条件**:
- 任务需要多个专业能力（前端+后端+测试）
- 任务可并行执行
- 需要协调多个 AI 代理

**所需能力**: L4（系统架构）

**解决方案**:
1. 定义代理职责（清晰的边界）
2. 设计通信协议（共享数据结构）
3. 实现编排器（调度、监控、失败处理）
4. 考虑冲突（文件锁、版本控制）

**架构设计**:
```yaml
orchestrator:
  agents:
    - name: backend-agent
      responsibility: API implementation
      input: schema
      output: code + tests
    - name: frontend-agent
      responsibility: UI implementation
      input: API spec
      output: components
  coordination:
    - parallel: [backend, frontend]
    - sequential: [code-review]
  failure_handling:
    - retry: 3
    - rollback: git reset
```

**时间**: 
- 设计：4 小时
- 实现：8 小时
- 收益：每个多组件任务节省 50% 时间

**复用次数**: 5 次
**成功率**: 78%
**最后更新**: 2026-01-04

**能力洞察**:
- L4 能力核心：系统思维、编排设计、失败恢复
- 从"使用多代理"到"设计编排系统"

**挑战**:
- 代理冲突检测
- 失败后的状态恢复
- 可观测性（日志、监控）

**相关模式**:
- [Pattern: 失败恢复机制](#pattern-failure-recovery)
```

---

## 📈 工具评估体系（动态更新）

### 原则：工具中立，能力优先

**不要硬编码工具名，而是建立发现机制**

### 工具分类

| 类别 | 用途 | 评估标准 |
|------|------|---------|
| UI 生成 | 快速前端原型 | 速度、质量、可定制性 |
| API 开发 | 后端接口 | 类型安全、文档生成 |
| 测试生成 | 自动化测试 | 覆盖率、可维护性 |
| 代码审查 | 质量保障 | 准确率、误报率 |

### 工具评估表（示例）

| 工具 | 类别 | 适用场景 | 平均时间 | 成功率 | 能力要求 | 最后评估 |
|------|------|---------|---------|--------|---------|----------|
| Lovable | UI 生成 | 完整应用 | 2min | 94% | L1-L2 | 2026-01 |
| v0.dev | UI 生成 | 单个组件 | 30s | 89% | L1-L2 | 2026-01 |
| fastapi-expert | API 开发 | FastAPI 端点 | 10min | 89% | L2 | 2026-01 |
| pytest-gen | 测试生成 | CRUD 测试 | 30s | 85% | L3 | 2026-01 |

### 工具发现流程

```markdown
当遇到新任务时：

1. **识别需求类别**
   - UI 生成？API 开发？测试？审查？

2. **查询工具数据库**
   - 当前类别有哪些工具？
   - 哪个工具最适合这个场景？

3. **评估新工具**
   - 试用 → 记录时间、成功率
   - 对比现有工具
   - 决定是否加入工具库

4. **定期淘汰**
   - 每月回顾成功率 <70% 的工具
   - 考虑替代方案
```

---

## 🚀 立即开始

### 今天（5 分钟）

**步骤 1: 自我诊断**

填写能力层级检查清单：

```markdown
## 我的能力层级诊断

### L1: 工具使用者
- [ ] 能在项目里把工具跑起来（环境/命令/上下文）
- [ ] 能读懂并小幅修改生成代码，让它通过基本运行/编译
- [ ] 能复现自己的工作流（prompt/命令/脚本），并定位明显错误

### L2: 协作工程师
- [ ] 能把需求写成验收标准（DoD），并明确约束/边界
- [ ] 能制定并执行验证计划（测试/静态检查/回归）
- [ ] 能端到端交付一个功能（含测试/文档/变更说明）
- [ ] 能解释关键权衡与失败原因（不是“碰巧跑通”）

### L3: 流程自动化者
- [ ] 能识别高频重复任务并量化 ROI（频率 × 时间）
- [ ] 创建了可复用自动化（脚本/命令/模板/CI job）
- [ ] 有清晰输入/输出契约 + 参数化 + 失败处理
- [ ] 自动化复用 ≥3 次且维护成本可控

### L4: 系统架构师
- [ ] 设计平台级系统（编排/插件化/扩展点清晰）
- [ ] 具备治理：观测/权限/成本/版本/回归
- [ ] 多人或多项目采用并能持续迭代

**结论**: 我目前在 [L1/L2/L3/L4]，目标是 [下一层级]
```

---

### 下一个任务（刻意练习）

**步骤 2: 选择一个 20% 任务**

标准：
- ✅ 有重复模式
- ✅ 可以设计可复用方案
- ✅ 时间允许深度思考

**步骤 3: 填写任务能力分析**

```markdown
## 任务能力分析（刻意练习）

**任务名称**: [描述]
**任务目标**: [X] 能力提升（20% 模式）
**目标层级**: [L2/L3/L4]
**我当前**: [L1/L2/L3]

**本次只练 1-2 个突破点**:
- [ ] [例如：写 DoD；补齐验证计划；把重复任务抽成契约]

**验收标准 (DoD)**:
- [ ] [可验证结果 1]
- [ ] [可验证结果 2]

**验证计划**:
- [ ] 测试/检查清单：[写清要跑什么、看什么结果]

**刻意练习计划**:
1. [动作 1]
2. [动作 2]

**成功证据**:
- [ ] [例如：测试通过；复用次数≥3；节省时间≥X]
```

---

### 每周回顾（周日，15 分钟）

**步骤 4: 填写能力检查**

```markdown
## Week X 能力检查

**当前层级**: [L2/L3]
**目标层级**: [L3/L4]

### 能力提升证据
- [ ] 本周识别了 X 个重复任务
- [ ] 创建了 X 个自动化
- [ ] 自动化复用了 X 次

**本周最大突破**:
[描述关键洞察]

**下周重点**:
[针对性练习计划]
```

---

## 💡 核心思想总结

### 从工具使用者到系统设计者

```
L1: "如何把它跑通？"
    ↓
L2: "如何交付并验收？"
    ↓
L3: "如何把这类事做成系统？" ← 当前突破点
    ↓
L4: "如何平台化并让他人持续使用？"
```

### 关键思维转变

| 层级 | 问的问题 | 关注点 |
|------|---------|--------|
| L1 | "能跑通吗？" | 工具执行与复现 |
| L2 | "怎么验收？怎么验证？" | 工程闭环与质量可证 |
| L3 | "怎么让未来更便宜？" | 系统化、复用与边际成本下降 |
| L4 | "怎么规模化给别人用？" | 平台治理、观测、安全与演进 |

### 终极目标

```
不是：更快地使用工具
而是：设计出新的工具

不是：优化任务执行
而是：提升工程能力

不是：完成更多任务
而是：构建更好的系统
```

---

## 📚 相关文档

- [CLAUDE.md](./CLAUDE.md) - 项目特定的 AI 协作指南
- [learning_notes/00_learning_strategy.md](./learning_notes/00_learning_strategy.md) - BPRT 学习法
- [claude-best-practices/](./claude-best-practices/) - AI 工程最佳实践

---

**创建日期**: 2025-01-04
**最后更新**: 2026-01-04
**版本**: 2.0 - 能力提升系统
**核心改变**: 从"任务优化"到"能力突破"
